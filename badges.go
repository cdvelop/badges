package badges

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

type BadgesHandler struct {
	args       []string
	outputFile string
	readmeFile string
	// stored initialization/parsing error; methods must check this
	err error
	// defaults for section update
	sectionID string
	afterLine string
	// configuration (moved from package-level constants)
	svgHeight    int
	badgeHeight  int
	fontSize     int
	labelPadding int
	valuePadding int
	badgeSpacing int
	labelBg      string
	badgesInfo   string
	// separate text used in the svg comment/header (matches original bash script)
	svgInfo string
}

// NewBadgeHandler creates a new BadgesHandler with defaults and processes args for special commands
// eg: output_svgfile:docs/img/custom.svg
func NewBadgeHandler(args ...string) *BadgesHandler {
	// Create handler with defaults
	h := &BadgesHandler{
		outputFile:   "docs/img/badges.svg",
		svgHeight:    20,
		badgeHeight:  20,
		fontSize:     11,
		labelPadding: 6,
		valuePadding: 6,
		badgeSpacing: 5,
		labelBg:      "#6c757d",
		badgesInfo:   "Generated by badges package from github.com/cdvelop/devscripts",
		svgInfo:      "Generated by badges.sh from github.com/cdvelop/devscripts",
	}

	// If the first argument is a directory (injected by gocurrentdir.sh),
	// treat it as the current working directory: verify .git exists there
	// and strip the injected directory before further processing.
	if len(args) > 0 {
		if fi, err := os.Stat(args[0]); err == nil && fi.IsDir() {
			gitPath := filepath.Join(args[0], ".git")
			if _, serr := os.Stat(gitPath); os.IsNotExist(serr) {
				h.err = fmt.Errorf("Git repository not found")
				return h
			}
			// remove the injected current-dir arg
			args = args[1:]
		}
	}

	if len(args) == 0 {
		// store error in handler containing the same user-facing messages
		// used by the original bash implementation so tests depending on
		// exact substrings continue to pass.
		h.err = fmt.Errorf("No badges specified\nUsage: badges.sh \"label:value:color\" \"label:value:color\" ...")
		return h
	}

	// assign args and process args to detect special commands (output_svgfile: and readmefile:)
	h.args = args
	// defaults
	h.readmeFile = "README.md"
	// default section values (private defaults)
	h.sectionID = "BADGES_SECTION"
	h.afterLine = "1"
	for _, a := range args {
		if strings.HasPrefix(a, "output_svgfile:") {
			h.outputFile = a[len("output_svgfile:"):]
			continue
		}
		if strings.HasPrefix(a, "readmefile:") {
			h.readmeFile = a[len("readmefile:"):]
			continue
		}
	}

	return h
}

// BuildBadges generates the SVG, writes it to the configured output file,
// and returns the badge markdown string and an error if any.
// BuildBadges generates the SVG, writes it to the configured output file,
// and returns the four arguments required by SectionUpdate as a slice of strings:
// [sectionID, afterLine, content, readmeFile]
func (h *BadgesHandler) BuildBadges() ([]string, error) {
	if h.err != nil {
		return nil, h.err
	}

	// First pass: collect parse errors/warnings like the bash implementation
	var errorMessages []string
	generatedBadgesCount := 0
	for _, p := range h.args {
		// skip special commands (already processed by NewBadgeHandler)
		if strings.HasPrefix(p, "output_svgfile:") || strings.HasPrefix(p, "readmefile:") {
			continue
		}
		_, perr := parseBadge(p)
		if perr != nil {
			// special command sentinel
			if strings.Contains(perr.Error(), "special command") {
				continue
			}
			// Normalize messages to match the bash tests expectations
			if strings.Contains(perr.Error(), "invalid badge format") {
				errorMessages = append(errorMessages, fmt.Sprintf("Error: Invalid badge format: %s", p))
			} else if strings.Contains(perr.Error(), "empty fields in badge") {
				errorMessages = append(errorMessages, fmt.Sprintf("Error: Empty fields in badge: %s", p))
			} else {
				errorMessages = append(errorMessages, fmt.Sprintf("Error: %s", perr.Error()))
			}
			continue
		}
		generatedBadgesCount++
	}

	// Generate SVG
	svgBytes, _, genErr := h.GenerateSVG()

	// Print accumulated error messages (tests look for these substrings)
	if len(errorMessages) > 0 {
		for _, m := range errorMessages {
			// print to stdout so tests can capture it
			println(m)
		}
	}

	if genErr != nil {
		// No valid badges case should match bash: print explicit message
		if generatedBadgesCount == 0 {
			println("Error: No valid badges to generate")
		}
		return nil, genErr
	}

	// ensure directory exists when writing file
	if err := os.MkdirAll(filepath.Dir(h.outputFile), 0o755); err != nil {
		return nil, fmt.Errorf("create output dir: %w", err)
	}

	// Check if file exists and content is the same (don't rewrite if identical)
	shouldWrite := true
	if existing, err := os.ReadFile(h.outputFile); err == nil {
		if bytes.Equal(existing, svgBytes) {
			shouldWrite = false
		}
	}

	if shouldWrite {
		if err := os.WriteFile(h.outputFile, svgBytes, 0o644); err != nil {
			return nil, fmt.Errorf("write svg file: %w", err)
		}
		// Print success message as in badges.bkp.sh
		println("Badges saved to " + h.outputFile)
	} else {
		println("SVG content is already up to date")
	}

	// Build the section args expected by SectionUpdate
	sectionContent := h.BadgeMarkdown()
	args := []string{h.sectionID, h.afterLine, sectionContent, h.readmeFile}
	return args, nil
}

// OutputFile returns the configured output SVG file path
func (h *BadgesHandler) OutputFile() string {
	if h.err != nil {
		return ""
	}
	return h.outputFile
}

// ReadmeFile returns the configured README file path
func (h *BadgesHandler) ReadmeFile() string {
	if h.err != nil {
		return ""
	}
	return h.readmeFile
}

// BadgeMarkdown builds the HTML/Markdown snippet that links to the SVG
// It always uses the handler's configured output file (`outputFile`).
// Example output: <a href="docs/img/custom.svg"><img src="docs/img/custom.svg" alt="Project Badges" title="Generated by badges package from github.com/cdvelop/devscripts"></a>
func (h *BadgesHandler) BadgeMarkdown() string {
	if h.err != nil {
		return ""
	}

	svgFile := h.outputFile
	return fmt.Sprintf(`<a href="%s"><img src="%s" alt="Project Badges" title="%s"></a>`,
		svgFile, svgFile, h.badgesInfo)
}

// Err returns any initialization or parsing error stored in the handler.
func (h *BadgesHandler) Err() error {
	return h.err
}
