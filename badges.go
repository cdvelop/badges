package badges

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// BadgesHandler is responsible for creating and managing a collection of badges.
// It handles parsing input arguments, generating the SVG image, and preparing
// the necessary markdown to embed the badges in a file.
//
// The handler is configured using a series of string arguments, where each argument
// defines a badge in the "label:value:color" format.
//
// Special commands can be passed as arguments to control the output:
//   - "output_svgfile:path/to/your.svg": Specifies the output file for the SVG image.
//   - "readmefile:path/to/your/README.md": Specifies the markdown file to be updated.
type BadgesHandler struct {
	args       []string
	outputFile string
	readmeFile string
	// stored initialization/parsing error; methods must check this
	err error
	// defaults for section update
	sectionID string
	afterLine string
	// configuration (moved from package-level constants)
	svgHeight    int
	badgeHeight  int
	fontSize     int
	labelPadding int
	valuePadding int
	badgeSpacing int
	labelBg      string
	badgesInfo   string
	// separate text used in the svg comment/header (matches original bash script)
	svgInfo string
}

// NewBadgeHandler creates and initializes a new BadgesHandler.
//
// It takes a variadic slice of strings as input. Each string can be a badge
// definition ("label:value:color") or a special command.
//
// Example:
//   handler := NewBadgeHandler(
//     "Go:1.18:#007d9c",
//     "Tests:Passing:#4c1",
//     "output_svgfile:docs/badges.svg",
//   )
func NewBadgeHandler(args ...string) *BadgesHandler {
	// Create handler with defaults
	h := &BadgesHandler{
		outputFile:   "docs/img/badges.svg",
		svgHeight:    20,
		badgeHeight:  20,
		fontSize:     11,
		labelPadding: 6,
		valuePadding: 6,
		badgeSpacing: 5,
		labelBg:      "#6c757d",
		badgesInfo:   "Generated by badges package from github.com/cdvelop/devscripts",
		svgInfo:      "Generated by badges.sh from github.com/cdvelop/devscripts",
	}

	// If the first argument is a directory (injected by gocurrentdir.sh),
	// treat it as the current working directory: verify .git exists there
	// and strip the injected directory before further processing.
	if len(args) > 0 {
		if fi, err := os.Stat(args[0]); err == nil && fi.IsDir() {
			gitPath := filepath.Join(args[0], ".git")
			if _, serr := os.Stat(gitPath); os.IsNotExist(serr) {
				h.err = fmt.Errorf("Git repository not found")
				return h
			}
			// remove the injected current-dir arg
			args = args[1:]
		}
	}

	if len(args) == 0 {
		// store error in handler containing the same user-facing messages
		// used by the original bash implementation so tests depending on
		// exact substrings continue to pass.
		h.err = fmt.Errorf("No badges specified\nUsage: badges.sh \"label:value:color\" \"label:value:color\" ...")
		return h
	}

	// assign args and process args to detect special commands (output_svgfile: and readmefile:)
	h.args = args
	// defaults
	h.readmeFile = "README.md"
	// default section values (private defaults)
	h.sectionID = "BADGES_SECTION"
	h.afterLine = "1"
	for _, a := range args {
		if strings.HasPrefix(a, "output_svgfile:") {
			h.outputFile = a[len("output_svgfile:"):]
			continue
		}
		if strings.HasPrefix(a, "readmefile:") {
			h.readmeFile = a[len("readmefile:"):]
			continue
		}
	}

	return h
}

// BuildBadges generates the SVG image, writes it to the specified output file,
// and returns a slice of strings intended for updating a markdown file.
//
// The returned slice contains the following elements in order:
// 1. sectionID: The ID of the markdown section to update.
// 2. afterLine: The line number after which the content should be inserted.
// 3. content: The markdown content to be inserted.
// 4. readmeFile: The path to the markdown file to be updated.
//
// This method centralizes the core logic of badge generation and file I/O.
func (h *BadgesHandler) BuildBadges() ([]string, error) {
	if h.err != nil {
		return nil, h.err
	}

	// First pass: collect parse errors/warnings like the bash implementation
	var errorMessages []string
	generatedBadgesCount := 0
	for _, p := range h.args {
		// skip special commands (already processed by NewBadgeHandler)
		if strings.HasPrefix(p, "output_svgfile:") || strings.HasPrefix(p, "readmefile:") {
			continue
		}
		_, perr := parseBadge(p)
		if perr != nil {
			// special command sentinel
			if strings.Contains(perr.Error(), "special command") {
				continue
			}
			// Normalize messages to match the bash tests expectations
			if strings.Contains(perr.Error(), "invalid badge format") {
				errorMessages = append(errorMessages, fmt.Sprintf("Error: Invalid badge format: %s", p))
			} else if strings.Contains(perr.Error(), "empty fields in badge") {
				errorMessages = append(errorMessages, fmt.Sprintf("Error: Empty fields in badge: %s", p))
			} else {
				errorMessages = append(errorMessages, fmt.Sprintf("Error: %s", perr.Error()))
			}
			continue
		}
		generatedBadgesCount++
	}

	// Generate SVG
	svgBytes, _, genErr := h.GenerateSVG()

	// Print accumulated error messages (tests look for these substrings)
	if len(errorMessages) > 0 {
		for _, m := range errorMessages {
			// print to stdout so tests can capture it
			println(m)
		}
	}

	if genErr != nil {
		// No valid badges case should match bash: print explicit message
		if generatedBadgesCount == 0 {
			println("Error: No valid badges to generate")
		}
		return nil, genErr
	}

	// ensure directory exists when writing file
	if err := os.MkdirAll(filepath.Dir(h.outputFile), 0o755); err != nil {
		return nil, fmt.Errorf("create output dir: %w", err)
	}

	// Check if file exists and content is the same (don't rewrite if identical)
	shouldWrite := true
	if existing, err := os.ReadFile(h.outputFile); err == nil {
		if bytes.Equal(existing, svgBytes) {
			shouldWrite = false
		}
	}

	if shouldWrite {
		if err := os.WriteFile(h.outputFile, svgBytes, 0o644); err != nil {
			return nil, fmt.Errorf("write svg file: %w", err)
		}
		// Print success message as in badges.bkp.sh
		println("Badges saved to " + h.outputFile)
	} else {
		println("SVG content is already up to date")
	}

	// Build the section args expected by SectionUpdate
	sectionContent := h.BadgeMarkdown()
	args := []string{h.sectionID, h.afterLine, sectionContent, h.readmeFile}
	return args, nil
}

// OutputFile returns the configured path for the output SVG file.
// This is the destination where the generated SVG image will be saved.
func (h *BadgesHandler) OutputFile() string {
	if h.err != nil {
		return ""
	}
	return h.outputFile
}

// ReadmeFile returns the configured path for the markdown file to be updated.
func (h *BadgesHandler) ReadmeFile() string {
	if h.err != nil {
		return ""
	}
	return h.readmeFile
}

// BadgeMarkdown generates the markdown snippet for embedding the badge image.
// The snippet is an HTML `<a>` tag containing an `<img>` tag, which is compatible
// with most markdown renderers.
//
// Example output:
//   <a href="docs/img/badges.svg"><img src="docs/img/badges.svg" alt="Project Badges" title="..."></a>
func (h *BadgesHandler) BadgeMarkdown() string {
	if h.err != nil {
		return ""
	}

	svgFile := h.outputFile
	return fmt.Sprintf(`<a href="%s"><img src="%s" alt="Project Badges" title="%s"></a>`,
		svgFile, svgFile, h.badgesInfo)
}

// Err returns any error that occurred during the initialization or processing
// of the BadgesHandler. It's important to check this error before proceeding
// with badge generation.
func (h *BadgesHandler) Err() error {
	return h.err
}
